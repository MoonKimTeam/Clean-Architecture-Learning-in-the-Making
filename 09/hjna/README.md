# 애플리케이션 조립하기

## 왜 조립까지 신경 써야 할까?

유스케이스와 영속성 어댑터를 직접 인스턴스화하면 코드 의존성이 잘못된 방향으로 흐르게 된다. 모든 의존성은 애플리케이션의 도메인 코드 방향으로 향해야 계층 변경에도 안전하다. 이를 위해 인터페이스 기반으로 의존성을 정의하고, 인터페이스 구현은 제공받아야 한다.

설정 컴포넌트는 모든 클래스에 필요한 의존성을 제공하고 인스턴스를 생성하며, 다음 역할을 수행한다.

* 웹 어댑터 인스턴스 생성
* HTTP 요청 전달 보장
* 유스케이스 인스턴스 생성
* 영속성 어댑터 인스턴스 생성
* 데이터베이스 접근 보장

설정 컴포넌트는 단일 책임 원칙을 유지하며, 애플리케이션의 작동에 필요한 구성 요소를 관리한다. 이는 애플리케이션이 유연성과 확장성을 유지하는 데 필수적이다.

## 평범한 코드로 조립하기

애플리케이션을 조립할 때 평범한 코드는 설정 컴포넌트를 명시적으로 구현하는 방식이다. 이는 각 클래스의 인스턴스를 직접 생성하고 의존성을 연결한다.

이 방식의 장점은 단순성과 명확성이다. main 메서드에서 모든 설정 과정을 시작하며, 웹 컨트롤러부터 영속성 어댑터까지 필요한 모든 인스턴스를 생성한 후 연결한다. 그러나 단점으로는 각 클래스가 public이어야 하며, 이는 필요 이상의 접근 범위를 제공할 위험이 있다.

package-private 접근 제한자를 사용하면 클래스 간 의존성을 최소화할 수 있다. 하지만 이러한 평범한 코드 방식은 애플리케이션 규모가 커질수록 비효율적일 수 있다.

## 스프링의 클래스패스 스캐닝으로 조립하기

스프링 프레임워크를 이용해 애플리케이션을 조립한 결과물을 애플리케이션 컨텍스트(application context)라고 한다. 애플리케이션 컨텍스트는 애플리케이션을 구성하는 모든 객체(자바 용어로는 ‘빈(bean)’)를 포함한다.

스프링은 애플리케이션 컨텍스트를 조립하기 위한 여러 방법을 제공하는데, 가장 인기 있는 방법은 클래스패스 스캐닝(classpath scanning)이다.

스프링은 클래스패스 스캐닝으로 클래스패스에서 접근 가능한 모든 클래스를 확인해 @Component 애노테이션이 붙은 클래스를 찾는다. 이렇게 찾아낸 클래스의 객체를 생성하고, 필요한 모든 필드를 인자로 받는 생성자를 호출하여 애플리케이션 컨텍스트에 추가한다. 이를 통해 애플리케이션을 효율적으로 조립할 수 있다.

이 방식의 단점은 클래스에 프레임워크에 특화된 애노테이션을 붙여야 한다는 점이다. 클린 아키텍처에서는 프레임워크와의 결합을 최소화해야 한다는 입장에서 이 방법을 지양할 수 있다. 또한, 클래스패스 스캐닝 방식이 너무 단순한 도구로 설계되어 있어 애플리케이션에 존재하는 모든 클래스를 정확히 파악하지 못할 가능성이 있다.

## 스프링의 자바 컨피그로 조립하기

스프링의 자바 컨피그 방식은 클래스패스 스캐닝 방식의 대안이다. 이 방식에서는 설정 클래스를 만들어 애플리케이션 컨텍스트에 필요한 빈을 직접 정의한다. 이는 특정 모듈만 포함하거나 다른 모듈의 빈을 모킹하여 애플리케이션 컨텍스트를 구성하는 데 유용하다.

빈 정의는 @Configuration과 @Bean 애너테이션을 사용하며, 빈 간의 의존성을 명시적으로 나타낼 수 있다. 예를 들어, AccountPersistenceAdapter 빈을 정의할 때 필요한 리포지토리와 매퍼를 파라미터로 받아 생성한다.

이 방식은 클래스패스 스캐닝 방식에 비해 스프링 프레임워크와의 결합도를 줄이고, 특정 프레임워크에 대한 의존성을 제거할 수 있다. 그러나 빈을 정의한 설정 클래스가 같은 패키지에 존재하지 않으면 이 빈들을 public으로 만들어야 하는 단점이 있다. 이러한 문제를 해결하기 위해 패키지별로 설정 클래스를 구분하여 사용하는 방법도 있다.

* 클래스패스 스캐닝은 아주 편리한 기능이다. 스프링에게 패키지만 알려주면 거기서 찾은 클래스로 애플리케이션을 조립한다. 이를 통해 애플리케이션 전체를 고민하지 않고도 빠르게 개발할 수 있게 된다. 하지만 코드의 규모가 커지면 금방 투명성이 낮아진다. 어떤 빈이 애플리케이션 컨텍스 트에 올라오는지 정확히 알 수 없게 된다. 또, 테스트에서 애플리케이션 컨텍스트의 일부 만 독립적으로 띄우기가 어려워진다.
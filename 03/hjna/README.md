# 코드 구성하기

## 계층으로 구성하기

계층 구조를 사용하는 첫 번째 접근법은 web, domain, persistence와 같은 전용 패키지를 두어 각 계층에 해당하는 역할을 수행하도록 구성하는 것이다. 예시로는 Account, AccountRepository, AccountService 등을 각각의 계층에 배치하여 의존성을 역전시키고, domain 패키지에 AccountRepository 인터페이스를 두어 persistence 패키지의 구현체가 이를 구현하도록 한다.

하지만 이 구조는 최적이 아니다. 애플리케이션의 기능 조각이나 특정 기능(feature)으로 구분짓지 않고 계층별로 나누기 때문에 의존성이 높은 경우 기능들이 엉켜 부수 효과를 일으킬 가능성이 크다. 또한, 애플리케이션이 제공하는 유스케이스가 무엇인지 파악하기 어려워 특정 기능을 찾기 위해 코드를 추적해야 하는 문제점이 있다.

이러한 계층적 구조는 육각형 아키텍처 스타일을 따르고자 하는 목적을 달성하기 어렵다. 계층 구조에서 web, persistence 패키지를 조사해도 어떤 기능이 호출되는지 한눈에 파악하기 어렵고, 인커밍(incoming) 포트와 아웃고잉(outgoing) 포트가 코드 속에 숨겨져 있기 때문이다.

## 기능으로 구성하기

기능 중심 패키징은 계층별로 나누는 방식과 달리, 관련된 모든 코드를 단일 패키지에 모아 넣는 접근법이다. 예를 들어, account와 같은 패키지에 Account, AccountController, AccountRepository와 같은 모든 관련 클래스를 포함시킨다. 이렇게 구성하면 계층 패키지가 사라지고 기능 단위로 패키지를 구성하게 된다.

패키지 간 불필요한 의존성을 방지하기 위해 접근 제어 수준을 설정할 수 있다. 특히, package-private 접근 제어를 사용하여 패키지 외부에서 접근하지 못하게 함으로써 각 기능 간의 독립성을 높일 수 있다.

로버트 마틴은 애플리케이션 기능이 드러나도록 코드 구조를 만드는 것을 ’소리치는 아키텍처(screaming architecture)’라 명명하였다. 기능 중심 패키징은 각 기능의 이름이 패키지명에 드러나므로, 구조를 보았을 때 어떤 기능을 포함하는지 쉽게 파악할 수 있는 장점이 있다.

그러나 이러한 기능 중심 패키징은 계층적 패키징보다 아키텍처의 가치를 떨어뜨릴 수 있다. 의존성 관리와 인커밍 포트, 아웃고잉 포트를 쉽게 식별할 수 없어 도메인 코드의 의존성을 효과적으로 역전시키지 못한다.

## 아키텍처적으로 표현력 있는 패키지 구조

육각형 아키텍처의 주요 요소는 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 그리고 어댑터이다. 이들은 각각의 역할에 맞게 계층적으로 배치되며, 인커밍 포트는 어플리케이션이 외부 요청을 받아들이는 역할을, 아웃고잉 포트는 외부 시스템과의 통신을 담당한다. 어댑터는 인커밍 포트를 호출하거나 아웃고잉 포트를 구현하며, web과 persistence 같은 어댑터 패키지가 이에 해당한다.

이 패키지 구조는 코드를 아키텍처적으로 명확히 구분하도록 하며, 코드 변경 시 패키지 간의 경계를 쉽게 파악할 수 있도록 한다. 이를 통해 아키텍처-코드 간의 갭을 줄이고, 코드를 유지보수하기 쉽게 만든다. 또한, 각 클래스는 public 또는 package-private 접근 수준을 설정하여 필요한 경우에만 외부에서 접근할 수 있도록 제어한다.

이러한 구조는 DDD의 바운디드 컨텍스트 개념과 잘 맞으며, 코드의 명확한 모듈화를 통해 특정 도메인 모델링을 가능하게 한다.

## 의존성 주입의 역할

클린 아키텍처의 핵심은 애플리케이션 계층이 인커밍과 아웃고잉 어댑터에 의존성을 갖지 않는 것이다. 인커밍 어댑터는 애플리케이션 서비스에서 정의된 포트를 통해 애플리케이션 코어의 기능을 호출한다. 반면, 아웃고잉 어댑터는 애플리케이션 서비스가 외부 시스템과 통신하기 위해 사용하는 인터페이스를 구현하여 제어의 흐름을 반대로 만든다. 이를 통해 어댑터는 애플리케이션에 대한 의존성을 역전시킨다.

의존성 주입은 애플리케이션 서비스에 필요한 인스턴스를 생성하고 주입하는 역할을 한다. 예를 들어, AccountController는 SendMoneyUseCase 인터페이스에 의존하지만, 실제 구현체는 의존성 주입을 통해 주어진다. 이렇게 함으로써 애플리케이션 계층과 어댑터 간의 결합을 줄이고, 서로 독립적으로 동작할 수 있게 된다.

이러한 구조는 변경과 유지보수를 용이하게 하며, 아키텍처의 일관성과 확장성을 보장한다.

## 유지보수 기흐한 소프트웨어를 만드는 데 어떻게 도움아 될까?

코드에서 아키텍처의 특정 요소를 찾으려면 이제 아키텍처 다이어그램의 박스 이름을 따라 패키지 구조를 탐색하면 된다.


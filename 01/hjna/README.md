# 계층형 아키텍처의 문제는 무엇일까?

계층형 아키텍처는 견고한 아키텍처 패턴이다.

계층을 잘 이해하고 구성한다면 웹 계층이나 영속성 계층에 독립적으로 도메인 로직을 작성할 수 있다. 원한다면 도메인 로직에 영향을 주지 않고 웹 계층과 영속성 계층에 사용된 기술을 변경할 수 있다.

계층형 아키텍처는 코드에 나쁜 습관들이 스며들기 쉽게 만들고 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 수많은 허점들을 노출한다. 

* 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다

웹 계층은 도메인 계층에 의존하고 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다.

데이터베이스의 구조를 먼저 구성하고 이를 토대로 도메인 로직을 구현하게 되는데, 비즈니스 관점에서는 전혀 맞지 않는 방법이다.

도메인 로직을 먼저 만들어야지 우리가 로직을 제대로 이해했는지 확인할 수 있다.

데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM의 사용이다. 

ORM 프레임워크를 계층형 아키텍처와 결합하면 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

영속성 코드가 사실상 도메인 코드에 녹아들어가서 둘 중 하나만 바꾸는 것이 어려워진다.

이는 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정확히 반대되는 상황이다.


* 지름길을 택하기 쉬워진다

전통적인 계층형 아키텍처에서는 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 것이다

만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 컴포넌트를 계층아래로 내려버리면 편리하지만, 영속성 계층은 컴포넌트를 아래 계층으로 내릴수록 비대해진다.

해당 규칙이 깨졌을 때 빌드가 실패하도록 강제하는 규칙 사용은 도움이 될 수 있다.

* 테스트하기 어려워진다

엔티티의 필드를 하나만 바꾸는 경우, 계층을 뛰어넘어 수행하는 일이 발생할 수 있다. 

이는 도메인 로직을 웹 계층에 구현해도록 강제하기 때문에, 애플리케이션 전반에 책임이 섞이게 된다.

또한, 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹해야한다는 점으로 테스트의 복잡도가 증가한다는 것이다.

테스트를 설정이 복잡해지는 것은 테스트를 전혀 작성하지 않는 방향으로 가는 첫걸음이다.

* 유스케이스를 숨긴다

계층형 아키텍처에서는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다. 

이럴 경우 새로운 기능을 추가할 적당한 위치를 찾는 일은 이미 어려워진 상태다.

또한 시간이 지나면 여러 개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어지기도 한다.

- 유스케이스 : 시스템의 하나 이상의 액터 또는 이해관계자에게 관측 가능한 결과를 산출하는 시스템에 의해 수행되는 일련의 활동의 명세

* 동시 작업이 어려워진다

계층형 아키텍쳐에서는 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고, 그다음에 도메인 계층을, 그리고 마지막으로 웹 계층을 만들어야 한다.

그렇기 때문에 특정 기능은 동시에 한 명의 개발자만 작업할 수 있다.

데이터베이스 주도 설계는 영속성 로직이 도메인 로직과 너무 뒤섞여서 각 측면을 개별적으로 작업할 수 없다.

* 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

올바르게 구축하고 몇 가지 추가적인 규칙들을 적용하면 계층형 아키텍처는 유지보수하기 매우 쉬워지며 코드를 쉽게 변경하거나 추가할 수 있게 된다.

하지만 엄격한 자기 훈련 없이는 시간이 지날수록 품질이 저하되고 유지보수하기가 어려워지기 쉽다.


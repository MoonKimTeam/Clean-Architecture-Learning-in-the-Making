# 4장 유스케이스 구현하기

순서: 도메인 엔티티 -> 유스케이스

## 도메인 모델 구현하기

- Account 엔티티
    - 기능: 잔고 계산, 출금, 출금 가능 여부 확인, 입금
    - Activity, Money와 같은 값 객체(VO) 사용

## 유스케이스 둘러보기

- 일반적인 유스케이스 단계: 입력 - 검증 - 모델 상태 조작 - 출력
- 유스케이스, 도메인 엔티티는 비즈니스 규칙을 검증할 책임이 있음

## 입력 유효성 검증

- 유효성 검증은 입력 모델이 다루도록 하기(송금하기 유스케이스에서는 SendMoneyCommand)
- 검증은 자바의 경우 Bean Validation API 사용(@NonNull 등)
- 입력 모델을 통해서 사실상 오류 방지 계층 만들 수 있음(입력 모델 내부에서 유효성 검증)

## 생성자의 힘

- 필드가 많다고 꼭 빌더 패턴이 능사는 아님.
- 생성자를 사용하면 꼭 필요한 필드를 빼먹는 것을 막을 수 있음

## 유스케이스마다 다른 입력 모델

- 공통 입력 모델이 필요한 경우(계좌 등록하기, 계좌 정보 업데이트하기)
    - 불변 커맨드 객체 필드에 null을 넣는 것은 코드 스멜임
    - 각 유스케이스 전용 입력 모델은 유스케이스를 훨신 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수 효과를 방지

## 비즈니스 규칙 검증하기

- 입력 유효성 검증은 유스케이스 로직의 일부가 아님
- 비즈니스 규칙은 유스케이스 로직의 일부
- 입력 유효성 검증은 구문상(syntactical), 비즈니스 규칙은 유스케이스 맥락 속에서 의미적(semantic) 유효성을 검증하는 일
    - "출금 계좌는 초과 출금되어서는 안 된다"라는 규칙은 비즈니스 규칙(모델 접근 필요)
    - "송금되는 금액은 0보다 커야 한다"라는 규칙은 입력 유효성 검증(모델 접근 불필요)
    - 논쟁의 여지는 있지만 이 구분법은 코드 위치 찾는 데 도움을 줌

## 풍부한 도메인 모델 vs. 빈약한 도메인 모델

- DDD 철학을 따르는 풍부한 도메인 모델
    - 엔티티에서 가능한 많은 도메인 로직이 구현됨
- 빈약한 도메인 모델에서는 엔티티 자체가 굉장일 얇음
    - 상태를 표현하는 필드, getter, setter 메서드만 포함
    - 도메인 로직이 유스케이스 클레스에 구현됨

## 유스케이스마다 다른 출력 모델

- 가장 최소한의 값
    - 송금 후 반환 값은 boolean or Account 객체? -> 정답은 없음
    - but, 의심스럽다면 가능한 적게 반환하자
- 출력 모델을 공유하게 되면 유스케이스들도 강하게 결합됨

## 읽기 전용 유스케이스는 어떨까

- 단순 쿼리는 읽기 전용 유스케이스로 구현
- 읽기 전용 쿼리는 CQS 또는 CQRS 개념과 잘 맞음


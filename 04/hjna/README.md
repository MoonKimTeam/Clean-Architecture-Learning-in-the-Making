# 유스케이스 구현하기

## 도메인 모델 구현하기

계좌 간 송금이라는 유스케이스를 객체지향적으로 구현하는 방법이 제시된다. 계좌(Account)는 기본 잔고와 활동 기록을 통해 잔액을 계산할 수 있도록 구성되며, 활동 기록(Activity)은 계좌에 발생한 입금과 출금 내역을 포함한다.

계좌의 현재 잔액은 기준 잔고에 활동 내역을 더하여 계산되며, 입출금 시에는 새로운 활동이 기록된다. 출금 시에는 잔액을 초과하지 않도록 규칙을 확인하며, 이러한 비즈니스 로직을 통해 계좌 간의 송금 유스케이스를 안전하게 처리할 수 있다.

## 유스케이스 둘러보기

### 유스케이스의 진행 단계
1. 입력을 받는다.
2. 비즈니스 규칙을 검증한다.
3. 모델상태를 조작한다.
4. 출력을 반환한다

저자는 유스케이스 코드가 도메인 로직에만 신경 써야 하고 입력 유효성 검증으로 오염되면 안 된다고 생각한다고 한다.

대신, 유스케이스는 비즈니스 규칙을 검증할 책임이 있다. 이 책임은 도메인 엔티티와 공유된다.

비즈니스 규칙을 충족시키기 위해 유스케이스는 입력을 기반으로 모델의 상태를 변경하거나, 외부 시스템과의 상호작용을 관리한다. 또한, 유스케이스는 외부 어댑터로부터 받은 입력값을 조작하여 비즈니스 로직을 실행하고, 최종적으로는 외부 어댑터로 반환할 출력 객체를 만들어낸다.

## 입력 유효성 검증

유스케이스는 하나 이상의 어댑터에서 호출되게 되는데, 이경우 유효성 검증을 각 어댑터에서 전부 구현해야 한다. 이렇게 된다면 실수를 하거나 검증을 해야한다는 것을 잊을 수도 있다.

입력 모델의 생성자 내에서 유효성 검증을 할 수 있다. 파라미터에 제약을 걸고 제약을 위반할 시 객체 생성을 막아버림으로서 해결할 수 있다. 또한 각 필드에 불변속성을 부여함으로 생성에 성공하고 나면 상태는 유효하고 이후에 잘못된 상태로 변경할 수 없다는 사실을 보장한다.

Bean Validation API를 사용하여 애너테이션을 통해 유효성 규칙을 정할 수 있다.

## 생성자의 힘

생성자의 파라미터는 클래스의 필수 속성들을 포함하며, 객체가 유효하지 않은 상태로 생성되는 것을 방지한다.

생성자가 복잡해질 경우, 빌더 패턴을 사용하여 더 편리하고 가독성 있게 객체를 생성할 수 있다. 빌더 패턴은 생성자의 파라미터가 많을 때 이를 단계적으로 설정할 수 있도록 하며, 필요한 필드만 초기화하여 유효한 객체를 생성할 수 있다. 빌더 패턴은 또한 필드 추가 시 코드의 변경을 간소화할 수 있어, 장기적인 코드 유지보수에도 유리하다.

## 유스케이스마다 다른 입력 모델

계좌 등록과 계좌 정보 업데이트라는 두 가지 유스케이스를 생각해보면, 두 경우 모두 계좌 정보가 필요하지만 요구되는 입력 데이터는 다르다. 계좌 정보 업데이트는 특정 계좌를 지정하기 위해 계좌 ID가 필요하지만, 계좌 등록에서는 계좌 ID가 null이어야 한다.

유효성 검증의 문제도 함께 다룬다. 입력 필드가 null을 허용하는 경우 코드의 냄새(code smell)가 될 수 있으며, 각 유스케이스가 각자의 유효성 검증 로직을 필요로 하기 때문에 입력 유효성을 검증하는 방식은 신중하게 설계되어야 한다. 이 과정에서 입력 모델을 공유하는 것은 유지보수 시 문제가 될 수 있다.

## 비즈니스 규칙 검증하기

입력 유효성 검증은 유스케이스의 로직 일부가 아니지만, 비즈니스 규칙 검증은 유스케이스 로직에 속한다. 입력 유효성 검증은 단순히 값이 null이 아닌지 확인하는 등의 구문적(syntactical) 검증을 포함하며, 이는 주로 어노테이션과 선언적인 방법으로 이루어진다. 반면, 비즈니스 규칙 검증은 의미적(semantical) 검증으로, 도메인 모델의 상태와 비즈니스 규칙을 바탕으로 한 보다 복잡한 검증을 포함한다.

비즈니스 규칙은 도메인 모델 내에 구현되며, “출금 계좌는 초과 인출되어서는 안 된다”와 같은 규칙이 그 예시다. 이러한 규칙은 도메인 엔티티 안에 위치해야 추론하기 쉽고 유지보수가 용이하다. 그러나 복잡한 비즈니스 규칙의 경우에는 데이터베이스 조회를 통해 상태를 확인하는 검증이 필요할 수도 있다.

유효성 검증은 도메인 엔티티 사용 전에도 수행될 수 있으며, 검증 실패 시에는 예외를 발생시켜 적절히 처리한다.

## 풍부한 도메인 모델 VS 빈약한 도메인 모델

### 풍부한 도메인 모델

풍부한 도메인 모델은 DDD(도메인 주도 설계) 철학을 따르며, 애플리케이션 코어에 있는 엔티티에 가능한 많은 도메인 로직을 구현한다. 엔티티는 상태를 변경하는 메서드를 포함하며, 비즈니스 규칙에 따라 유효한 변경만 허용한다. 이 방식은 예제의 Account 엔티티에서 볼 수 있듯이 엔티티 자체가 비즈니스 로직을 처리하는 중심 역할을 한다. 유스케이스는 사용자의 의도를 표현하며, 이 의도를 도메인 엔티티의 메서드 호출로 변환하는 진입점 역할을 한다. 결과적으로 많은 비즈니스 규칙이 유스케이스가 아닌 엔티티에 구현된다.

예를 들어, 송금하기 유스케이스에서는 출금 계좌와 입금 계좌 엔티티를 불러와 withdraw()와 deposit() 메서드를 호출하고, 결과를 데이터베이스에 저장한다. 이 과정에서 초과 출금을 방지하는 등의 복잡한 비즈니스 규칙은 단순화를 위해 생략할 수 있다.

### 빈약한 도메인 모델

빈약한 도메인 모델은 엔티티가 상태를 표현하는 필드와 단순한 getter, setter 메서드만 포함하며, 비즈니스 로직은 포함하지 않는다. 이러한 방식에서는 도메인 로직이 유스케이스 클래스에 구현되며, 유스케이스가 비즈니스 규칙 검증과 엔티티의 상태 변경을 책임진다. 엔티티를 데이터베이스에 전달하는 역할도 유스케이스가 맡는다.

## 유스케이스마다 다트 출력 모델

‘송금하기’ 유스케이스의 코드는 boolean 값을 반환한다. 이는 최소한의 정보로 작업의 성공 여부를 호출자에게 전달하는 것이다. 반면, 특정 유스케이스에서는 Account 객체를 반환해 계좌의 새로운 잔액과 같은 추가 정보를 제공할 수도 있다. 그러나 호출자가 이 데이터가 필요하지 않다면, 굳이 반환할 필요는 없으며, 다른 유스케이스에서 재사용할 수 있는 범용적인 데이터 접근 방식은 지양해야 한다.

저자는 유스케이스 간에 출력 모델을 공유할 경우, 유스케이스 간의 결합도가 높아질 위험이 있다고 설명한다. 공유 모델은 새로운 필드가 필요할 때 관련이 없는 다른 유스케이스에도 영향을 줄 수 있다. 이는 시간이 지나며 모델이 점차 커지게 되어 유지보수가 어려워지는 문제를 초래할 수 있다. 따라서 단일 책임 원칙을 적용해 유스케이스마다 개별적인 출력 모델을 사용하고, 필요할 때 유스케이스에 맞게 모델을 분리해 사용하는 것이 중요하다고 강조한다.

## 읽기 전용 유스케이스는 어떨까?

읽기 전용 유스케이스를 만드는 작업은 단순한 데이터 조회이기 때문에, 일반적으로 애플리케이션 코드에서 데이터베이스를 직접 쿼리하는 방식으로 구현된다.

읽기 전용 작업은 유스케이스로 언급하기 다소 어색할 수 있지만, 프로젝트의 일관성 유지와 체계화를 위해 다른 유스케이스와 비슷한 방식으로 구현할 수 있다. 예를 들어, GetAccountBalanceService는 GetAccountBalanceQuery 인터페이스를 구현하고, LoadAccountPort를 통해 데이터베이스로부터 데이터를 불러온다.

이러한 읽기 전용 유스케이스는 쓰기 가능한 유스케이스와 구분되어야 한다. 이는 CQS나 CQRS와 같은 개념과 밀접한 관련이 있다. 

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

아키텍처가 도메인 로직을 원하는 대로 구현할 수 있도록 허용하면서도, 유스케이스별로 입출력 모델을 독립적으로 모델링함으로써 예상치 못한 부수 효과를 피할 수 있다.

각 유스케이스마다 별도의 모델을 만드는 것은 더 많은 작업이 필요하다. 각 유스케이스마다 모델을 정의하고, 이를 도메인 엔터티와 매핑해야 하기 때문이다. 하지만 이 방식은 유스케이스를 명확하게 이해할 수 있도록 해주고, 장기적으로 유지보수성을 높인다. 명확한 유스케이스별 모델링은 여러 개발자가 동시에 다양한 유스케이스에서 작업할 때 혼란을 줄여준다.
